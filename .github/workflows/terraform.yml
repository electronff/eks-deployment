
name: 'Terraform'

on:
  push:
    branches:
    - master
  pull_request:

jobs:
  # build_push:
  #   name: 'Build_image'
  #   runs-on: ubuntu-latest
  #   steps:
  #   - uses: actions/checkout@v2
  #     name: Check out code
  #   - uses: mr-smithers-excellent/docker-build-push@v5
  #     name: Build & push Docker image
  #     with:
  #       image: muritala/pyhonapp
  #       tags: latest
  #       registry: docker.io
  #       dockerfile: Dockerfile.ci
  #       username: ${{ secrets.DOCKER_USERNAME }}
  #       password: ${{ secrets.DOCKER_PASSWORD }}

  # terraform:
  #   name: 'Terraform'
  #   needs: 'build_push'
  #   runs-on: ubuntu-latest
  #   environment: Dev

  #   # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
  #   defaults:
  #     run:
  #       shell: bash

  #   steps:
  #   # Checkout the repository to the GitHub Actions runner
  #   - name: Checkout
  #     uses: actions/checkout@v2

  #   # Install the latest version of Terraform CLI and configure the Terraform CLI configuration file with a Terraform Cloud user API token
  #   - name: Setup Terraform
  #     uses: hashicorp/setup-terraform@v1
  #     with:
  #       cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}

  #   # Initialize a new or existing Terraform working directory by creating initial files, loading any remote state, downloading modules, etc.
  #   - name: Terraform Init
  #     run: terraform init

  #   # Checks that all Terraform configuration files adhere to a canonical format
  #   - name: Terraform Format
  #     run: terraform fmt

  #   # Generates an execution plan for Terraform
  #   - name: Terraform Plan
  #     run: terraform plan
  #     env:
  #       AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #       AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #       AWS_REGION: ${{ secrets.AWS_REGION }}

  #     # On push to master, build or change infrastructure according to Terraform configuration files
  #     # Note: It is recommended to set up a required "strict" status check in your repository for "Terraform Cloud". See the documentation on "strict" required status checks for more information: https://help.github.com/en/github/administering-a-repository/types-of-required-status-checks
  #   - name: Terraform Apply
  #     if: github.ref == 'refs/heads/master' && github.event_name == 'push'
  #     run: terraform apply --auto-approve
  #     env:
  #         AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #         AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #         AWS_REGION: ${{ secrets.AWS_REGION}}
          
  #   # - name: Terraform Destroy
  #   #   run: terraform destroy --auto-approve
  #   #   env:
  #   #     AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #   #     AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #   #     AWS_REGION: ${{ secrets.AWS_REGION }}




  Deployment:
    runs-on: ubuntu-latest
    # needs: 'build_push'
    steps:
      - name: Checkout
        uses: actions/checkout@v2
      # - name: delete exixting deployment and service
      #   run: |
      #     kubectl delete pyservice
      - name: Push image and deploy
        uses: observian/littleci-littlecd-eks@master
        with:
          access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          account_id: ${{ secrets.AWS_ACCOUNT_ID }}
          repo: webapp
          region: ${{ secrets.AWS_REGION }}
          tags: 0.1.1.${{ github.run_number }},${{ github.sha }}
          eks_cluster_name: terraform-eks-demo
          k8s_image_tag: 0.1.1.${{ github.run_number }}
          k8s_manifest: deployment.yml
          


      # - run: docker build --tag webapp:latest .
      # - name: Push to ECR
      #   id: ecr
      #   uses: jwalton/gh-ecr-push@v1
      #   with:
      #     access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
      #     secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      #     region: us-east-1
      #     image: webapp:latest


  # deploy:
  #     runs-on: ubuntu-latest
  #     steps:
  #       - uses: actions/checkout@v2
  #       - name: Deploy
  #         uses: GavinRay97/garden-eks-deploy-action@v1.0
  #         env:
  #           aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
  #           aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  #           aws_region: $AWS_REGION
  #           cluster_name: $EKS_CLUSTER_NAME
  #           kubeconfig_cluster_name: $KUBECONFIG_CLUSTER_NAME
  #         with:
  #           args: |
  #             export KUBECONFIG=/github/home/.kube/config
  #             webapp:latest deploy --env=aws

